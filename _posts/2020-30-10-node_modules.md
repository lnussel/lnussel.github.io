---
layout: post
title:  "Packaging Software using Node.js"
date: 2020-10-30
---
## Intro

### The Node.js world

Software written in Node.js typically relies on several external
components to implement certain useful features. So called "node
modules". For developers the system is quite convenient to use with
the `npm` tool. The tool basically reads a json file that specifies
the modules required. Those modules are then fetched from a central
registry in the internet,
[https://www.npmjs.com/](https://www.npmjs.com/). Since modules in
turn also require other modules, the dependencies are
resolved and fetched recursively. The result is placed in a
`node_modules` directory and can be used from there. The `npm` tool
also has features to update the modules.

Node.js modules often have very specific functions with limited
scope. Therefore typical software depends on hundreds if not
thousands of modules. In contrast to many other systems the
name space of imported module isn't flat. So in Node.js different
modules may and do depend on different versions of other modules. So
the result of imported modules is actually a tree with some modules
appearing in several places in different versions.

Moreover sometimes node modules are bindings to native libraries. In
such cases the `npm` tool would either compile the bindings locally
or fetch pre-built binaries from somewhere in the internet. Node.js
does not seem to provide a framework for that so each module has to
implement the handling of native components itself. Since compiling
native components would require to have compilers, headers and other
native development tools installed, some modules seem to prefer
downloading pre-built binaries. The compilation result resp the
downloaded binaries are also stored in the `node_modules` directory
next to the sources.
An application would typically run directly from the source
directory. The concept of global components or installation outside
the current directory does not exist.

### The Linux distribution's world

In openSUSE software is delivered as RPM packages. Packages can
express dependencies that are also expected to be delivered as RPM
packages. A package manager takes care to resolve dependencies at
install time and to download all required additional packages from the
configured repositories. Apart from the specified dependencies
packages themselves are self-contained and are expected to be
installable fully offline and unattended. Means a package can not
download additional content at install time.
Package are always installed system wide. Actual applications or
services would normally run as unprivileged user with no write
access to their components.

With packages building and installation/deployment are strictly
separated. A package build also follows strict rules. All components
are expected to be built unattended from original, unmodified
("pristine") upstream source archives. That allows to track the
origin of software. In case modifications are needed to adopt the
software to the packaging, those changes are applied as separate
patches on top of the original sources. So it's clear at any point
in time to anyone looking at the sources what's original and what's
changed.

In case of openSUSE also all sources must be locally available to
the build server which does not have network access during package
build. That ensures that packages can be rebuilt from source in the
exact same way at any future point in time, independent of what
happens in the internet.

Normally each upstream component is created as separate package.
Both in terms of building as well as resulting binary RPMs.
That approach allows for sharing components, avoiding duplication
and allows flexible combinations at run time to build e.g. small
systems.

### Combining both worlds

The Node.js approach with downloading everything from the internet,
no separation of build and install time and lack of global
components is in direct conflict with how RPM packages work. Yet
Linux distributions have to deal with Node.js components as
especially web software uses it to build the user interfaces.
Such software may have to be shipped as RPM for seamless integration
into the system. An example of that is the
[Cockpit](https://cockpit-project.org/) project. It combines
traditional, native system components with a web interface build on
Javascript.

#### The Cockpit approach

Fortunately cockpit does not use Node.js at run time. It's only used
to build the web interface. So in order to avoid having to deal with
Node.js in the RPM build system, the cockpit project generates all
web related files already in their CI system. The upstream release
tarballs therefore contain compiled CSS and minified Javascript.
When building the RPM packages, only the traditional bits have to be
compiled. The web interface is copied unmodified. From a users'
perspective that works as Javascript execution in the browser is not
architecture specific.

Nevertheless that approach violates the principle of building from
source. Minified JS and CSS basically have to be treated like
binaries. They cannot easily be patched and adjusted from within the
package build.

#### npm2rpm

The naive approach from packaging side would be to create an rpm
package for each node module. There's even a script that
automatically creates spec files:
[npm2rpm](https://github.com/theforeman/npm2rpm).

Cockpit has more than 1300 dependencies though. Generating those
packages could probably be automated. However, node modules with the
same name are required in different versions. That doesn't map well
into rpm world. So that method isn't practical either.

npm2rpm has another operation mode though were it would bundle all
dependencies. It even generates individual source lines into the
spec file so the upstream URL of each tarball is recorded.
It then generates some cache file for use by `npm install` later
during the build.
That's quite good as this approach mostly fulfills the requirement
of pristine upstream sources. The npm cache file as source isn't
nice though. Also the generated spec file is quite complex. So for
the use case of cockpit that won't really work in practice as it
makes updating complex.

#### obs-service-node_modules
